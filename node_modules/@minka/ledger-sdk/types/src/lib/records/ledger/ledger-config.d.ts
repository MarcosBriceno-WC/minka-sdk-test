import { LedgerHandle } from '../../common/ledger-handle';
export declare enum LedgerConfigKey {
    AccessStrategy = "access.strategy",
    IntentExpiryThresholdMinutes = "intent.expiryThresholdMinutes",
    IntentExpiryThresholdMinutesDeprecated = "intentExpiryThresholdMinutes",
    IntentCreditorInitiatedTransfersEnabled = "intent.creditorInitiatedTransfersEnabled",
    DomainResolutionFromHandleEnabled = "domain.resolutionFromHandleEnabled",
    AnchorWalletRequired = "anchor.walletRequired",
    PolicyScheduleProcessorEnabled = "policy.scheduleProcessorEnabled",
    TrapsEnabled = "traps.enabled",
    RequestJournalingEnabled = "request.journalingEnabled",
    AggregatedLimitsEnabled = "limits.aggregated.enabled",
    AuthenticationTwoFactorEnabled = "authentication.twoFactor.enabled",
    ForwardAnchorCreate = "forward.anchor.create",
    ForwardAnchorUpdate = "forward.anchor.update",
    ForwardAnchorDrop = "forward.anchor.drop",
    ForwardAnchorGet = "forward.anchor.get",
    ForwardAnchorSign = "forward.anchor.sign",
    ForwardAnchorFindAll = "forward.anchor.findAll",
    ForwardAnchorStrategy = "forward.anchor.strategy",
    ForwardAnchorCreateStrategy = "forward.anchor.create.strategy",
    ForwardAnchorUpdateStrategy = "forward.anchor.update.strategy",
    ForwardAnchorDropStrategy = "forward.anchor.drop.strategy",
    ForwardAnchorGetStrategy = "forward.anchor.get.strategy",
    ForwardAnchorSignStrategy = "forward.anchor.sign.strategy",
    ForwardAnchorFindAllStrategy = "forward.anchor.findAll.strategy"
}
export declare enum LedgerAccessStrategy {
    RecordBased = "record-based",
    PolicyBased = "policy-based"
}
export declare enum ForwardStrategy {
    None = "none",
    Proxy = "proxy",
    Fallback = "fallback",
    Validate = "validate"
}
/**
 * Ledger config object that contains common configuration options.
 */
export type LedgerForwardingConfig = {
    /**
     * Forwarding URL for creating anchors. If set, the ledger will
     * forward calls to create anchors to the specified Bridge.
     *
     * The bridge has to handle the request just like the ledger would.
     * The body returned in response, however, will be discarded.
     */
    [LedgerConfigKey.ForwardAnchorCreate]?: LedgerHandle;
    /**
     * Forwarding URL for updating anchors. If set, the ledger will
     * forward calls to create anchors to the specified Bridge.
     *
     * The bridge has to handle the request just like the ledger would.
     * The body returned in response, however, will be discarded.
     */
    [LedgerConfigKey.ForwardAnchorUpdate]?: LedgerHandle;
    /**
     * Forwarding URL for dropping anchors. If set, the ledger will
     * forward calls to create anchors to the specified Bridge.
     *
     * The bridge has to handle the request just like the ledger would.
     * The body returned in response, however, will be discarded.
     */
    [LedgerConfigKey.ForwardAnchorDrop]?: LedgerHandle;
    /**
     * Forwarding URL for getting an anchor. If set, the ledger will
     * first check its own DB for the anchor. If it does not exist there,
     * it will forward the call to the specified Bridge.
     *
     * The bridge has to handle the request just like the ledger would.
     * The body returned in response, however, will be discarded.
     */
    [LedgerConfigKey.ForwardAnchorGet]?: LedgerHandle;
    /**
     * Forwarding URL for signing anchors. If set, the ledger will
     * forward calls to sign an anchor to the specified Bridge.
     *
     * The bridge has to handle the request just like the ledger would.
     * The body returned in response, however, will be discarded.
     */
    [LedgerConfigKey.ForwardAnchorSign]?: LedgerHandle;
    /**
     * Forwarding URL for finding anchors. If set, the ledger will
     * forward calls to find anchors to the specified Bridge.
     *
     * The bridge has to handle the request just like the ledger would.
     * The body returned in response from the bridge will be signed and returned by the ledger.
     */
    [LedgerConfigKey.ForwardAnchorFindAll]?: LedgerHandle;
    /**
     * Global forwarding strategy for anchors.
     * If set, the ledger will forward calls to anchors to the specified Bridge.
     * The following description applies to all actions of anchors, and it's overridden by the action specific forwarding strategy.
     * If set to 'none', the ledger will not forward calls to anchors.
     * If set to 'proxy', the ledger will forward calls to the specified Bridge without managing the entity/entities locally in the ledger.
     * If set to 'fallback', the ledger will forward calls to anchors to the specified Bridge when the entity/entities are not found in the ledger.
     * If set to 'validate', the ledger will forward calls to anchors to the specified Bridge and return the entity/entities after asserting consistency e.g., proofs and hash, in the ledger.
     */
    [LedgerConfigKey.ForwardAnchorStrategy]?: ForwardStrategy;
    /**
     * Create forwarding strategy for anchors.
     * If set, the ledger will forward calls to create anchors to the specified Bridge.
     * If not set, ledger will check the global forwarding strategy for anchors.
     * If set to 'none', the ledger will not forward calls to create anchors.
     * If set to 'proxy', the ledger will forward calls to create anchors to the specified Bridge without storing the entity locally in the ledger.
     * If set to 'validate', the ledger will forward calls to create anchors to the specified Bridge and return the entity from the bridge after asserting its consistency e.g., proofs and hash.
     */
    [LedgerConfigKey.ForwardAnchorCreateStrategy]?: ForwardStrategy;
    /**
     * Update forwarding strategy for anchors.
     * If set, the ledger will forward calls to update anchors to the specified Bridge.
     * If not set, ledger will check the global forwarding strategy for anchors.
     * If set to 'none', the ledger will not forward calls to update anchors.
     * If set to 'proxy', the ledger will forward calls to update anchors to the specified Bridge without updating the entity locally in the ledger.
     * If set to 'validate', the ledger will forward calls to update anchors to the specified Bridge and return the entity from the bridge after asserting its consistency e.g., proofs and hash.
     */
    [LedgerConfigKey.ForwardAnchorUpdateStrategy]?: ForwardStrategy;
    /**
     * Drop forwarding strategy for anchors.
     * If set, the ledger will forward calls to drop anchors to the specified Bridge.
     * If not set, ledger will check the global forwarding strategy for anchors.
     * If set to 'none', the ledger will not forward calls to drop anchors.
     * If set to 'proxy', the ledger will forward calls to drop anchors to the specified Bridge without deleting the entity locally in the ledger.
     * If set to 'validate', the ledger will forward calls to drop anchors to the specified Bridge and return the entity from the bridge after asserting its consistency e.g., proofs and hash.
     */
    [LedgerConfigKey.ForwardAnchorDropStrategy]?: ForwardStrategy;
    /**
     * Get forwarding strategy for anchors.
     * If set, the ledger will forward calls to find an anchor to the specified Bridge.
     * If not set, ledger will check the global forwarding strategy for anchors.
     * If set to 'none', the ledger will not forward calls to find anchors.
     * If set to 'proxy', the ledger will forward calls to find anchors to the specified Bridge without returning the entity stored locally in the ledger.
     * If set to 'fallback', the ledger will forward calls to find anchors to the specified Bridge when the entities are not found in the ledger.
     */
    [LedgerConfigKey.ForwardAnchorGetStrategy]?: ForwardStrategy;
    /**
     * Sign forwarding strategy for anchors.
     * If set, the ledger will forward calls to sign anchors to the specified Bridge.
     * If not set, ledger will check the global forwarding strategy for anchors.
     * If set to 'none', the ledger will not forward calls to sign anchors.
     * If set to 'proxy', the ledger will forward calls to sign anchors to the specified Bridge without signing the entity locally in the ledger.
     * If set to 'validate', the ledger will forward calls to sign anchors to the specified Bridge and return the entity from the bridge after asserting its consistency e.g., proofs and hash.
     */
    [LedgerConfigKey.ForwardAnchorSignStrategy]?: ForwardStrategy;
    /**
     * Find all forwarding strategy for anchors.
     * If set, the ledger will forward calls to find all anchors to the specified Bridge.
     * If not set, ledger will check the global forwarding strategy for anchors.
     * If set to 'none', the ledger will not forward calls to find all anchors.
     * If set to 'proxy', the ledger will forward calls to find all anchors to the specified Bridge without returning the entities stored locally in the ledger.
     * If set to 'fallback', the ledger will forward calls to find all anchors to the specified Bridge when the entities are not found in the ledger.
     */
    [LedgerConfigKey.ForwardAnchorFindAllStrategy]?: ForwardStrategy;
};
export type LedgerAuthenticationConfig = {
    /**
     * Flag that controls whether 2FA is enabled for authentication. Right now
     * this flag is only consumed by studio.
     * By default false.
     */
    [LedgerConfigKey.AuthenticationTwoFactorEnabled]?: boolean;
};
export type LedgerLimitsConfig = {
    /**
     * Flag that controls whether the ledger will support aggregated limits.
     * By default false.
     */
    [LedgerConfigKey.AggregatedLimitsEnabled]?: boolean;
};
export type LedgerIntentConfig = {
    /**
     * Threshold for intent expiry in minutes. Intents that have not
     * finished processing in the specified amount of time will be
     * expired and as a consequence the entire corresponding thread
     * will be aborted.
     */
    [LedgerConfigKey.IntentExpiryThresholdMinutes]: number;
    /**
     * Flag that controls whether third party initiated intents are allowed.
     * If set to true, third party initiated intents will be enabled, as intents will not be
     * checked against spend wallet rule until we get debit prepare confirmation first.
     * Default value is 'false', meaning that third party initiated intents are disabled.
     */
    [LedgerConfigKey.IntentCreditorInitiatedTransfersEnabled]?: boolean;
};
export type LedgerDomainConfig = {
    /**
     * Flag that controls whether the ledger will support extracting the domain of a record from its handle.
     * If set to true, the ledger will support extracting the domain of a record from its handle.
     * Otherwise, the ledger will only support determining the domain of a record from proofs.
     */
    [LedgerConfigKey.DomainResolutionFromHandleEnabled]?: boolean;
};
export type LedgerPolicyConfig = {
    /**
     * Flag that controls the Ledger schedule policy feature. If set to true
     * the schedule policy processor will be turned on and process schedule
     * policies.
     */
    [LedgerConfigKey.PolicyScheduleProcessorEnabled]?: boolean;
};
export type LedgerAnchorConfig = {
    /**
     * Defines whether a wallet must exist or
     * not as a constraint to create an anchor.
     * This flag is also checked when dropping
     * an anchor in order to forbid the deletion
     * if the anchor wallet is a real wallet
     * in the system.
     * Default value is 'true'.
     */
    [LedgerConfigKey.AnchorWalletRequired]?: boolean;
};
export type LedgerTrapsConfig = {
    /**
     * Flag that controls if Ledger traps are enabled.
     * Note this depend on the server having this feature enabled as well.
     * By default traps are disabled.
     */
    [LedgerConfigKey.TrapsEnabled]?: boolean;
};
export type LedgerRequestConfig = {
    /**
     * Flag that enables journaling of requests for both incoming and outgoing
     * requests. This depends on the server configuration to allow journaling
     * as well.
     */
    [LedgerConfigKey.RequestJournalingEnabled]?: boolean;
};
export type LedgerAccessConfig = {
    /**
     * Flag that controls the mode of access control for the ledger.
     * By default 'record-based'.
     * When set to 'record-based', the ledger will only support access control rules set on records - including ledger and domains.
     * When set to 'policy-based', the ledger will only support access control rules configured with policies that doesn't have to be attached to records.
     *
     * Once set to 'policy-based', it cannot be changed to 'record-based' because the user(s) would lock themselves out of the ledger.
     */
    [LedgerConfigKey.AccessStrategy]?: LedgerAccessStrategy;
};
export type LedgerConfig = LedgerForwardingConfig & LedgerAuthenticationConfig & LedgerLimitsConfig & LedgerIntentConfig & LedgerDomainConfig & LedgerAnchorConfig & LedgerAccessConfig & LedgerPolicyConfig & LedgerTrapsConfig & LedgerRequestConfig;
